<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>new操作符做了什麽</title>
      <link href="2020/10/12/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E9%BA%BD/"/>
      <url>2020/10/12/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E9%BA%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS基礎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this的指向</title>
      <link href="2020/10/12/this%E7%9A%84%E6%8C%87%E5%90%91/"/>
      <url>2020/10/12/this%E7%9A%84%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在JS函數内部，有兩個特殊的對象：<code>arguments</code>和<code>this</code>。</p><p><code>arguments</code>是一個類數組對象，包含著傳入的所有參數，其主要用途就是保存函數參數。</p><p><code>this</code>引用的是函數據以執行的環境對象/上下文環境（context），其行爲和Java、C#中的<code>this</code>大致相似。</p><p>但是，在Java等面向對象的語言中，<code>this</code>關鍵字的含義是明確而具體的，即指代當前對象，一般在編譯器綁定。而在JS中，<code>this</code>是動態綁定的，在運行期才綁定。因爲如此，JS中<code>this</code>的指向很容易使初學者感到疑惑，本篇文章的目的就是希望能解除關於<code>this</code>指向問題疑惑。</p><p>簡單地說，**<code>this</code>的指向在函數定義時是確定不了的，只有在函數執行時才能確定<code>this</code>到底指向誰，而且實際上<code>this</code>最終指向的是那個調用它的對象。**</p><p>上面這句是精簡的結論，大部分時候這樣理解沒問題，但其實是不準確的，後面會舉例説明，來對<code>this</code>的指向有一個全面的理解。</p><h3 id="函數中使用this"><a href="#函數中使用this" class="headerlink" title="函數中使用this"></a>函數中使用<code>this</code></h3><p>當函數被直接調用時，此時<code>this</code>綁定到全局對象。在瀏覽器中，全局對象就是<code>window</code>對象。</p><p>所以在如下例子中，<code>window</code>對象沒有<code>user</code>屬性，打印出來就是<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.user);  <span class="comment">// undefined, window沒有user屬性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">fn();  <span class="comment">// 在全局作用域中直接調用</span></span><br></pre></td></tr></table></figure><p>在全局作用域直接調用函數等價於<code>window.fn();</code></p><blockquote><p>注：在嚴格模式下，<code>this</code>指向的不是<code>window</code>，而是<code>undefined</code></p></blockquote><h3 id="對象方法中使用this"><a href="#對象方法中使用this" class="headerlink" title="對象方法中使用this"></a>對象方法中使用<code>this</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    user: <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();  <span class="comment">// Peter</span></span><br></pre></td></tr></table></figure><p>根據我們的精簡結論，誰調用方法<code>this</code>就指向誰，在上述例子中，是<code>fn()</code>是通過<code>obj.fn()</code>執行的，所以<code>this</code>指向<code>obj</code>。</p><p>以上兩個例子過於簡單，其實説的都不準確，看下面幾個例子，才能徹底搞懂<code>this</code>的指向。</p><h3 id="進一步討論this的例子"><a href="#進一步討論this的例子" class="headerlink" title="進一步討論this的例子"></a>進一步討論<code>this</code>的例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    user: <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.obj.fn();  <span class="comment">// Peter</span></span><br></pre></td></tr></table></figure><p>看上面這個例子，如果按照精簡結論「誰調用的就指向誰」，那麽<code>this</code>應該指向<code>window</code>，但實際上<code>this</code>指向的是<code>obj</code>。</p><p>我們先不解釋，再來看下面這個例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    user: <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line">    o: &#123;</span><br><span class="line">        user: <span class="string">&quot;Michelle&quot;</span></span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.o.fn();  <span class="comment">// Michelle</span></span><br></pre></td></tr></table></figure><p>可以看到，方法由<code>obj</code>調用，但是<code>this</code>指向的仍然是<code>o</code>。</p><p>這樣看來，精簡結論好像是錯的(○´･д･)ﾉ，不過我們進行一些補充，就可以在精簡結論的基礎上，對<code>this</code>的指向有全面的認識。</p><h4 id="補充如下"><a href="#補充如下" class="headerlink" title="補充如下"></a>補充如下</h4><p><strong>① 當函數被直接調用，<code>this</code>指向<code>window</code></strong></p><p><strong>② 當函數被一個對象調用，<code>this</code>指向這個對象</strong></p><p><strong>③ 當函數被多級對象調用，<code>this</code>指向的是上一級的對象</strong></p><p>還有一种比較特殊的情況，看下面這個例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    user: <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line">    o: &#123;</span><br><span class="line">        user: <span class="string">&quot;Michelle&quot;</span></span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.user);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> func = obj.o.fn; </span><br><span class="line">func();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>這裡<code>this</code>指向的是<code>window</code>，我們要看的是函數最後執行的時候是誰調用的，由於<code>obj.o.fn</code>被賦值給<code>func</code>時還沒有執行，所以當<code>func()</code>執行時，執行的對象是<code>window</code>。</p><h3 id="構造函數中使用this"><a href="#構造函數中使用this" class="headerlink" title="構造函數中使用this"></a>構造函數中使用<code>this</code></h3><p>JS支持面向對象式編程，但與主流的面向對象式編程語言不同，JS並沒有類（class）的概念，而是使用基於原型（prototype）的繼承方式。</p><p>相應的，JS中的構造函數也很特殊，如果不使用<code>new</code>調用，則和普通函數一樣。</p><p>作爲約定俗成的規定，構造函數以大寫字母開頭，可以提醒調用者用正確的方式調用。如果調用正確，<code>this</code>綁定到新創建的對象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Fn(<span class="string">&quot;Peter&quot;</span>);  <span class="comment">// this指向新創建的對象，所以a才有user屬性</span></span><br><span class="line"><span class="built_in">console</span>.log(a.user);  <span class="comment">// Peter</span></span><br></pre></td></tr></table></figure><p>從上面的例子中可以看到，用<code>Fn()</code>創建實例的時候，構造函數中使用的<code>this</code>指向的是新創建的對象<code>a</code>。</p><p>想具體知道<code>new</code>操作符做了什麽的，可以看這篇文章 <a href=""></a></p><h4 id="當構造函數中有return時，this的指向"><a href="#當構造函數中有return時，this的指向" class="headerlink" title="當構造函數中有return時，this的指向"></a>當構造函數中有<code>return</code>時，<code>this</code>的指向</h4><p>首先，一個函數，要作爲一個真正意義上的構造函數，需滿足以下條件：</p><ol><li>在函數内部對新對象（<code>this</code>）的屬性進行設置，通常是添加屬性和方法。</li><li>構造函數可以包含返回（<code>return</code>）語句（不推薦），但返回值必須是<code>this</code>，或其他非引用類型的值。</li></ol><p><strong>在JS構造函數中的<code>return</code>，如果返回了基本類型（<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>）的值，那麽對構造函數沒有影響；如果返回了引用類型的值（<code>Object</code>、<code>Array</code>、<code>Function</code>），那麽我們<code>new</code>出來的對象會被返回的引用類型值給替換。</strong></p><p>下面舉幾個例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 構造函數返回空對象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user);  <span class="comment">// undefined, a為空對象&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 構造函數返回Funtion類型的值，為引用類型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user);  <span class="comment">// undefined, a為f ()&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 構造函數返回基本類型的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user);  <span class="comment">// Peter, 沒有影響</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 構造函數返回基本類型的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user);  <span class="comment">// Peter, 沒有影響</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 構造函數返回基本類型的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;Peter&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user);  <span class="comment">// Peter, 沒有影響</span></span><br></pre></td></tr></table></figure><h3 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h3><ul><li><p><a href="https://www.cnblogs.com/pssp/p/5216085.html">彻底理解js中this的指向，不必硬背</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html">深入浅出 JavaScript 中的 this</a></p></li><li><p><a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and “this”</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS基礎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS浮動和清除浮動</title>
      <link href="2020/10/10/CSS%E6%B5%AE%E5%8B%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8B%95/"/>
      <url>2020/10/10/CSS%E6%B5%AE%E5%8B%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8B%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSS浮動"><a href="#CSS浮動" class="headerlink" title="CSS浮動"></a>CSS浮動</h2><h3 id="float屬性"><a href="#float屬性" class="headerlink" title="float屬性"></a>float屬性</h3><p>在CSS中，任何元素都可以浮動，且任何設置了浮動（float）屬性的元素都會變成塊級元素。因此，浮動（float）經常用於佈局。</p><p>浮動有以下特點：</p><ul><li>浮動的框可以向左或向右移動，直到外邊緣碰到包含框或另一個浮動框的邊框。</li><li><strong>浮動可以理解為讓某個元素脫離標準流，漂浮在標準流之上，和標準流不是一个層次</strong></li></ul><p>浮動（float）屬性有三種取值：</p><ul><li>left：向左浮動</li><li>right：向右浮動</li><li>none：不浮動，默認值</li></ul><p><em>注：<a href="https://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html">CSS浮動通俗講解</a> 這篇講得很通俗易懂，有助於理解</em></p><h3 id="會帶來什麽問題"><a href="#會帶來什麽問題" class="headerlink" title="會帶來什麽問題"></a>會帶來什麽問題</h3><p>用一個例子來演示，用一個div包裹住圖片，圖片長寬皆設爲250px。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;250&quot;</span> <span class="attr">height</span>=<span class="string">&quot;250&quot;</span> <span class="attr">src</span>=<span class="string">&quot;link_to_the_picture&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>現在沒事，div能夠包裹住其内部的元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然後簡單設置樣式，img先不設置float屬性，看下效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="comment">/*寬度設窄，方便截圖</span></span><br><span class="line"><span class="comment">    width: 30%;</span></span><br><span class="line"><span class="comment">    /*設置邊框看得更清楚*/</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="comment">/*位置居中*/</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ptrln216/HexoStaticFile@46690a4a46cfa065a69d8b265d012e314f921929/2020/10/10/47c693ebfe61afa5fb88d13b00b67cbc.png"></p><p>可以看到div的黑邊框包裹住了圖片，接著設置float屬性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ptrln216/HexoStaticFile@52356ace4db2287b01dfa6bb849491c2fc9a8edd/2020/10/10/0c0f4de1f372edde72cf194c3ec6a8d3.png"></p><p>可以看到，div不再包裹img了，float屬性破壞了我們的佈局。</p><p>好在，我們有幾種方法可以用來解決這個問題。</p><h2 id="清除浮動的8種方法"><a href="#清除浮動的8種方法" class="headerlink" title="清除浮動的8種方法"></a>清除浮動的8種方法</h2><h3 id="1-父級div設置height"><a href="#1-父級div設置height" class="headerlink" title="1. 父級div設置height"></a>1. 父級div設置height</h3><p>原理：父級div手動設置height，就可以解決父級div無法自動獲取高度的問題。</p><p>優點：簡單、代碼少</p><p>缺點：只適合固定高度的佈局，要給出精確的高度</p><p>建議：不推薦使用，高度固定的佈局可以使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CSS</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*清除浮動*/</span></span><br><span class="line">    height: 300px;  // 因爲已知圖片高為250px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ptrln216/HexoStaticFile@328a874089717fac655fb9657b027934f5983c28/2020/10/10/4b9d3da5893a16f1b2a1beefefd5f635.png"></p><h3 id="2-浮動元素後加上空div標簽，並加上clear-both樣式"><a href="#2-浮動元素後加上空div標簽，並加上clear-both樣式" class="headerlink" title="2. 浮動元素後加上空div標簽，並加上clear: both樣式"></a>2. 浮動元素後加上空div標簽，並加上clear: both樣式</h3><p>原理：添加一個空div，並利用CSS提供的clear: both清除浮動，這樣一來這個空div會因爲兩邊不能有浮動元素，而被放到浮動元素的下方（和最下邊緣對齊），而容器元素就能自動獲取正確的高度了</p><p>優點：簡單、代碼少、瀏覽器支持好</p><p>缺點：浮動佈局多的話，要添加很多無語義的html元素，代碼不夠優雅，後期不易維護</p><p>建議：不推薦使用，但此方法是以前主要使用的一種    </p><pre><code>HTML&lt;div&gt;    &lt;img width=&quot;250&quot; height=&quot;250&quot; src=&quot;link_to_the_picture&quot;&gt;    &lt;p&gt;利用空div設置clear: both，自動獲取高度&lt;/p&gt;    &lt;!-- 清除浮動 --&gt;    &lt;div class=&quot;clearFloat&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CSS</span></span><br><span class="line"><span class="comment">/*清除浮動*/</span></span><br><span class="line"><span class="selector-class">.clearFloat</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圖中故意畫出空div的border，可以清楚的看到空div被擠壓到浮動元素下方。容器元素由此自動獲得高度。</p><p><img src="https://cdn.jsdelivr.net/gh/ptrln216/HexoStaticFile@b5f93880eab8b11f766c14c3918f067d3fc4e4b4/2020/10/10/67ece70c7dcc5367f8ea8ad0d235664c.png"></p><h3 id="3-父級div定義僞類-after和zoom"><a href="#3-父級div定義僞類-after和zoom" class="headerlink" title="3. 父級div定義僞類::after和zoom"></a>3. 父級div定義僞類::after和zoom</h3><p>原理：原理和方法2類似，zoom是IE專有屬性，用來解決IE的浮動問題</p><p>優點：瀏覽器支持性好，目前大型網站都有使用</p><p>缺點：代碼多，且要兩句代碼結合使用才能讓主流瀏覽器都支持</p><p>建議：推薦使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearFloat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;250&quot;</span> <span class="attr">height</span>=<span class="string">&quot;250&quot;</span> <span class="attr">src</span>=<span class="string">&quot;link_to_the_picture&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父類定義僞類:after和zoom<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CSS</span></span><br><span class="line"><span class="selector-class">.clearFloat</span> &#123;</span><br><span class="line">    <span class="attribute">zoom</span>: <span class="number">1</span>;  <span class="comment">/*IE專用*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearFloat</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ptrln216/HexoStaticFile@6955888672662574dabf6b4729616c8d002acdc5/2020/10/10/b609548305832ee4e8f7f81524194ec1.png"></p><h3 id="4-父級div定義overflow-hidden"><a href="#4-父級div定義overflow-hidden" class="headerlink" title="4. 父級div定義overflow: hidden"></a>4. 父級div定義overflow: hidden</h3><p>原理：必須定義width（或zoom: 1），同時不能定義height，瀏覽器會自動檢查浮動區域的高度</p><p>優點：簡單、代碼少、瀏覽器支持好</p><p>缺點：不能和position配合使用，因爲超出尺寸的會被隱藏</p><p>建議：只推薦沒有使用position，或對overflow: hidden理解比較深的朋友使用</p><h3 id="5-父級div定義overflow-auto"><a href="#5-父級div定義overflow-auto" class="headerlink" title="5. 父級div定義overflow: auto"></a>5. 父級div定義overflow: auto</h3><p>原理：和方法4類似</p><p>優點：簡單、代碼少、瀏覽器支持好</p><p>缺點：内部寬高超過父級div時，會出現滾動條</p><p>建議：不推薦使用，除非你需要滾動條，或確定不會出現滾動條</p><hr><p><strong>以下3種方法只作瞭解，不推薦使用</strong></p><h3 id="6-父級div也一起浮動"><a href="#6-父級div也一起浮動" class="headerlink" title="6. 父級div也一起浮動"></a>6. 父級div也一起浮動</h3><p>原理：所有代碼一起浮動就變成一個整體</p><p>缺點：會產生新的浮動問題</p><h3 id="7-父級div定義display-table"><a href="#7-父級div定義display-table" class="headerlink" title="7. 父級div定義display: table"></a>7. 父級div定義display: table</h3><p>原理：將div變成表格屬性</p><p>缺點：會產生新的未知問題</p><h3 id="8-結尾處加br-hr標簽，並添加clear-both"><a href="#8-結尾處加br-hr標簽，並添加clear-both" class="headerlink" title="8. 結尾處加br/hr標簽，並添加clear: both"></a>8. 結尾處加br/hr標簽，並添加clear: both</h3><p>原理：父級div要記得定義zoom: 1，來解決IE的浮動問題</p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS佈局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/29/hello-world/"/>
      <url>2020/09/29/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p> 看到很多文章和大佬，都推薦養成寫博客的習慣，所以就試著搭一個屬於自己的博客網站，一方面記錄前端的學習過程，就當作是寫學習筆記；另一方面也給自己一個鍛煉文筆的機會，畢竟提高文筆是2020年初給自己設的三大目標之一。</p><p>在網上查了一圈，加上之前忘記從哪聼到過Hexo，最終用了Hexo這個網誌框架。不得不説，用起來十分簡便，而且效果令人滿意，官網上有好多好看的主題可以白嫖(●’◡’●)，後面也會介紹怎麽應用不同的主題。</p><p>這篇文章作爲第一篇post，簡單記錄下是怎麽從0到1，搭建出現在這個網站的。</p><h2 id="前期準備"><a href="#前期準備" class="headerlink" title="前期準備"></a>前期準備</h2><p>在安裝Hexo前，需先安裝<a href="https://nodejs.org/en/">Node.js</a>和<a href="https://git-scm.com/">Git</a>。</p><p>都安裝好後，用npm就可以完成Hexo的安裝。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="快速開始"><a href="#快速開始" class="headerlink" title="快速開始"></a>快速開始</h2><p>訪問<a href="https://hexo.io/">Hexo</a>官網，跟著文檔即可快速開始。這裡記錄一些<strong>常用的指令和步驟</strong>。</p><h3 id="建立專案"><a href="#建立專案" class="headerlink" title="建立專案"></a>建立專案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;  // &lt;folder&gt;即爲專案名，如果省略則在當前目錄下生成專案</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install  // 安裝依賴</span><br></pre></td></tr></table></figure><p>建立完成後，專案資料夾下會有如下結構</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml   // 大部分配置都在此完成</span><br><span class="line">├── package.json  // 記錄了專案有哪些依賴</span><br><span class="line">├── scaffolds     // 鷹架，建立新文章時，Hexo會根據scaffolds來建立檔案</span><br><span class="line">├── <span class="built_in">source</span>        // 放置内容的地方</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes        // 主題放置在這</span><br></pre></td></tr></table></figure><h3 id="寫作"><a href="#寫作" class="headerlink" title="寫作"></a>寫作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span>    // 默認是post</span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>佈局</th><th>路徑</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft（草稿）</td><td>source/_drafts</td></tr></tbody></table><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="啓動服務器"><a href="#啓動服務器" class="headerlink" title="啓動服務器"></a>啓動服務器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>預設是<code>http://localhost:4000/</code>。</p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="產生靜態檔案"><a href="#產生靜態檔案" class="headerlink" title="產生靜態檔案"></a>產生靜態檔案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><table><thead><tr><th>選項</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>產生完即部署網站</td></tr><tr><td>-w, –watch</td><td>監看檔案變更</td></tr></tbody></table><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除快取檔案 (<code>db.json</code>) 和已產生的靜態檔案 (<code>public</code>)</p><h3 id="部署網站"><a href="#部署網站" class="headerlink" title="部署網站"></a>部署網站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>一般先清除，再部署。</p><p>部署到哪可以在配置文件裡設定，我部署到<a href="https://github.com/">Github</a>上，而且倉庫名叫做<code>&lt;username&gt;.github.io</code>，這樣部署完成後，可以直接用Github Page的服務，免費獲得一個自己的在線網站。</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="美化網站"><a href="#美化網站" class="headerlink" title="美化網站"></a>美化網站</h2><p>Hexo有很多好看的主題可以套用，可以逛逛官網的主題區，説不定會找到符合自己需求的主題，省下很多功夫。</p><p>我選擇了<a href="https://demo.jerryc.me/">Butterfly</a>，安裝教程照著文檔走即可，不是很複雜，先安裝再配置就行了。</p><h3 id="圖床"><a href="#圖床" class="headerlink" title="圖床"></a>圖床</h3><p>如果喜歡為文章設定封面的話，爲了加快加載速度、減少本地圖片，建議使用圖床來存儲圖片。</p><p>我使用的是<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>作爲上傳軟體，上傳到GitHub作爲圖床（jsdelivr加速）。</p><p>具體怎麽配置可以參考這篇 <a href="https://www.antmoe.com/posts/c9c6437b/index.html">配置picgo成为多平台图床工具</a></p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>不得不説，套用主題可以快速的有點樣子，不過要好看還是得下一番功夫。</p><p>這裡附上一個大佬的博客，寫得很好，想要進一步美化的十分推薦去看看。</p><p><a href="https://www.antmoe.com/index.html">小康博客</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
